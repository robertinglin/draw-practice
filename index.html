<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>2D Drawing Tool - Smooth Pressure Interpolation</title>
        <style>
            #reload {
                top: 20px;
                left: 20px;
                position: absolute;
                z-index: 1000;
            }
            body {
                margin: 0;
                overflow: hidden;
                font-family: Arial, sans-serif;
            }
            #container {
                width: 100vw;
                height: 100vh;
                position: relative;
            }
            #drawing-canvas,
            #temp-canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }
            #brush-cursor {
                position: fixed;
                pointer-events: none;
                z-index: 1000;
                display: none;
            }
            #controls {
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(255, 255, 255, 0.8);
                padding: 10px;
                border-radius: 5px;
            }
            #size-slider {
                width: 200px;
            }
            #drawing-canvas,
            #temp-canvas {
                cursor: none;
            }
        </style>
    </head>
    <body>
        <button id="reload" onclick="window.location.reload()">Reload</button>
        <div id="container">
            <canvas id="drawing-canvas"></canvas>
            <canvas id="temp-canvas"></canvas>
            <svg id="brush-cursor" width="40" height="40">
                <circle
                    cx="20"
                    cy="20"
                    r="19"
                    fill="none"
                    stroke="black"
                    stroke-width="1"
                />
            </svg>
            <div id="controls">
                <input
                    type="range"
                    id="size-slider"
                    min="1"
                    max="100"
                    value="50"
                />
                <span id="size-value">Max: 50px</span><br />
            </div>
        </div>
        <script>
            class DrawingTool {
                constructor() {
                    this.canvas = document.getElementById("drawing-canvas");
                    this.ctx = this.canvas.getContext("2d");
                    this.tempCanvas = document.getElementById("temp-canvas");
                    this.tempCtx = this.tempCanvas.getContext("2d");
                    this.brushCursor = document.getElementById("brush-cursor");
                    this.sizeSlider = document.getElementById("size-slider");
                    this.sizeValue = document.getElementById("size-value");

                    this.isDrawing = false;
                    this.points = [];
                    this.lastPoint = null;
                    this.maxBrushSize = 50;
                    this.undoStack = [];

                    this.initializeEventListeners();
                    this.resizeCanvas();
                    this.updateMaxBrushSize();
                    this.saveState();
                }

                initializeEventListeners() {
                    window.addEventListener("resize", () =>
                        this.resizeCanvas(),
                    );
                    this.sizeSlider.addEventListener("input", () =>
                        this.updateMaxBrushSize(),
                    );
                    this.tempCanvas.addEventListener("pointerdown", (e) =>
                        this.startDrawing(e),
                    );
                    this.tempCanvas.addEventListener("pointermove", (e) =>
                        this.draw(e),
                    );
                    this.tempCanvas.addEventListener("pointerup", () =>
                        this.stopDrawing(),
                    );
                    this.tempCanvas.addEventListener("pointerleave", () =>
                        this.stopDrawing(),
                    );
                    this.tempCanvas.addEventListener("pointermove", (e) =>
                        this.updateBrushCursor(e),
                    );
                    this.tempCanvas.addEventListener("pointerleave", () =>
                        this.hideBrushCursor(),
                    );
                    document.addEventListener("keydown", (e) => {
                        if (e.ctrlKey && e.key === "z") {
                            e.preventDefault();
                            this.undo();
                        }
                    });
                }

                resizeCanvas() {
                    const tempImageData = this.ctx.getImageData(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height,
                    );
                    this.canvas.width = this.tempCanvas.width =
                        window.innerWidth;
                    this.canvas.height = this.tempCanvas.height =
                        window.innerHeight;
                    this.ctx.putImageData(tempImageData, 0, 0);
                    [this.ctx, this.tempCtx].forEach((ctx) => {
                        ctx.lineCap = ctx.lineJoin = "round";
                    });
                }

                updateMaxBrushSize() {
                    this.maxBrushSize = parseInt(this.sizeSlider.value);
                    this.sizeValue.textContent = `Max: ${this.maxBrushSize}px`;
                }

                updateBrushCursor(e) {
                    const pressure =
                        e.pressure !== undefined ? e.pressure : 0.5; // Default to 0.5 if pressure is not available
                    const size = this.calculateCursorSize(pressure);
                    this.brushCursor.style.left = `${e.clientX - size}px`;
                    this.brushCursor.style.top = `${e.clientY - size}px`;
                    this.brushCursor.style.display = "block";
                    this.brushCursor.setAttribute("width", size * 2);
                    this.brushCursor.setAttribute("height", size * 2);
                    this.brushCursor.firstElementChild.setAttribute("cx", size);
                    this.brushCursor.firstElementChild.setAttribute("cy", size);
                    this.brushCursor.firstElementChild.setAttribute(
                        "r",
                        size - 1,
                    );
                    const opacity = 1;
                    this.brushCursor.firstElementChild.setAttribute(
                        "stroke-opacity",
                        opacity,
                    );
                }

                calculateCursorSize(pressure) {
                    return Math.max(4, this.maxBrushSize * pressure);
                }

                calculateBrushSize(pressure) {
                    return Math.max(1, this.maxBrushSize * pressure); // Ensure minimum size of 1
                }

                calculateOpacity(pressure) {
                    return Math.max(0.1, pressure); // Ensure minimum opacity of 0.1
                }

                hideBrushCursor() {
                    this.brushCursor.style.display = "none";
                }

                startDrawing(e) {
                    this.isDrawing = true;
                    this.points = [];
                    this.lastPoint = null;
                    this.addPoint(e);
                }

                draw(e) {
                    if (!this.isDrawing) return;
                    e.preventDefault();
                    this.addPoint(e);
                    this.drawCachedLine();
                }

                addPoint(e) {
                    const pressure = e.pressure || 0;
                    if (pressure === 0) return; // Don't add point if there's no pressure

                    const newPoint = {
                        x: e.offsetX,
                        y: e.offsetY,
                        pressure: pressure,
                    };

                    this.points.push(newPoint);
                    this.lastPoint = newPoint;
                }

                drawCachedLine() {
                    this.tempCtx.clearRect(
                        0,
                        0,
                        this.tempCanvas.width,
                        this.tempCanvas.height,
                    );

                    if (this.points.length < 2) return;

                    this.tempCtx.beginPath();

                    // Helper function for Catmull-Rom interpolation
                    const catmullRom = (p0, p1, p2, p3, t) => {
                        const t2 = t * t;
                        const t3 = t2 * t;
                        return {
                            x:
                                0.5 *
                                (2 * p1.x +
                                    (-p0.x + p2.x) * t +
                                    (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) *
                                        t2 +
                                    (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                            y:
                                0.5 *
                                (2 * p1.y +
                                    (-p0.y + p2.y) * t +
                                    (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) *
                                        t2 +
                                    (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3),
                            pressure:
                                0.5 *
                                (2 * p1.pressure +
                                    (-p0.pressure + p2.pressure) * t +
                                    (2 * p0.pressure -
                                        5 * p1.pressure +
                                        4 * p2.pressure -
                                        p3.pressure) *
                                        t2 +
                                    (-p0.pressure +
                                        3 * p1.pressure -
                                        3 * p2.pressure +
                                        p3.pressure) *
                                        t3),
                        };
                    };

                    // We need at least 4 points for Catmull-Rom spline
                    if (this.points.length >= 4) {
                        for (let i = 0; i < this.points.length - 3; i++) {
                            const p0 = this.points[i];
                            const p1 = this.points[i + 1];
                            const p2 = this.points[i + 2];
                            const p3 = this.points[i + 3];

                            // Interpolate between p1 and p2
                            for (let t = 0; t <= 1; t += 0.1) {
                                const pt = catmullRom(p0, p1, p2, p3, t);
                                const size = this.calculateBrushSize(
                                    pt.pressure,
                                );
                                const opacity = this.calculateOpacity(
                                    pt.pressure,
                                );

                                this.tempCtx.lineWidth = size;
                                this.tempCtx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
                                this.tempCtx.lineTo(pt.x, pt.y);
                                this.tempCtx.stroke();
                                this.tempCtx.beginPath();
                                this.tempCtx.moveTo(pt.x, pt.y);
                            }
                        }
                    } else {
                        // Fallback to simple line for fewer points
                        this.points.forEach((point) => {
                            this.tempCtx.lineWidth = this.calculateBrushSize(
                                point.pressure,
                            );
                            this.tempCtx.strokeStyle = `rgba(0, 0, 0, ${this.calculateOpacity(point.pressure)})`;
                            this.tempCtx.lineTo(point.x, point.y);
                            this.tempCtx.stroke();
                            this.tempCtx.beginPath();
                            this.tempCtx.moveTo(point.x, point.y);
                        });
                    }
                }

                stopDrawing() {
                    if (this.isDrawing) {
                        this.isDrawing = false;
                        this.ctx.drawImage(this.tempCanvas, 0, 0);
                        this.tempCtx.clearRect(
                            0,
                            0,
                            this.tempCanvas.width,
                            this.tempCanvas.height,
                        );
                        this.saveState();
                    }
                }

                saveState() {
                    this.undoStack.push(this.canvas.toDataURL());
                }

                undo() {
                    if (this.undoStack.length > 1) {
                        this.undoStack.pop(); // Remove the current state
                        const img = new Image();
                        img.onload = () => {
                            this.ctx.clearRect(
                                0,
                                0,
                                this.canvas.width,
                                this.canvas.height,
                            );
                            this.ctx.drawImage(img, 0, 0);
                        };
                        img.src = this.undoStack[this.undoStack.length - 1];
                    } else if (this.undoStack.length === 1) {
                        // If there's only one state (the initial blank state), clear the canvas
                        this.ctx.clearRect(
                            0,
                            0,
                            this.canvas.width,
                            this.canvas.height,
                        );
                    }
                }
            }

            new DrawingTool();
        </script>
    </body>
</html>
