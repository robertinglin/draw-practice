<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>3D Drawing Practice Tool</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                font-family: Arial, sans-serif;
            }
            #container {
                display: flex;
                width: 100vw;
                height: 100vh;
            }
            #webgl-container {
                width: 50%;
                height: 100%;
            }
            #drawing-container {
                width: 50%;
                height: 100%;
                position: relative;
            }
            #drawing-canvas,
            #temp-canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }
            #brush-cursor {
                position: fixed;
                pointer-events: none;
                z-index: 1000;
                display: none;
            }
            #controls {
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(255, 255, 255, 0.8);
                padding: 10px;
                border-radius: 5px;
            }
            #size-slider {
                width: 200px;
            }
            #drawing-canvas,
            #temp-canvas {
                cursor: none;
                background: transparent;
            }
            #shape-selector {
                position: absolute;
                top: 20px;
                left: 20px;
                z-index: 1000;
            }
            #color-picker-container {
                position: absolute;
                top: 60px;
                left: 20px;
                background: rgba(255, 255, 255, 0.8);
                padding: 10px;
                border-radius: 5px;
            }
            #pen-color-toggle {
                position: absolute;
                top: 100px;
                left: 20px;
                background: rgba(255, 255, 255, 0.8);
                padding: 10px;
                border-radius: 5px;
            }

            #reload-button {
                position: absolute;
                top: 20px;
                left: 160px;
                background: rgba(255, 255, 255, 0.8);
                padding: 5px;
                border: none;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <div id="drawing-container">
                <canvas id="drawing-canvas"></canvas>
                <canvas id="temp-canvas"></canvas>
                <svg id="brush-cursor" width="40" height="40">
                    <circle
                        cx="20"
                        cy="20"
                        r="19"
                        fill="none"
                        stroke="black"
                        stroke-width="1"
                    />
                </svg>
                <div id="controls">
                    <input
                        type="range"
                        id="size-slider"
                        min="1"
                        max="100"
                        value="50"
                    />
                    <span id="size-value">Max: 50px</span><br />
                </div>
            </div>
            <div id="webgl-container"></div>
        </div>
        <select id="shape-selector">
            <option value="sphere">Sphere</option>
            <option value="cube">Cube</option>
            <option value="cylinder">Cylinder</option>
            <option value="cone">Cone</option>
            <option value="upload">Upload OBJ</option>
        </select>
        <button id="reload-button" onClick="window.location.reload();">
            Reload
        </button>
        <div id="color-picker-container">
            <label for="background-color">Background Color:</label>
            <input type="color" id="background-color" value="#888888" />
        </div>
        <div id="pen-color-toggle">
            <label for="pen-color">Pen Color:</label>
            <select id="pen-color">
                <option value="black">Black</option>
                <option value="white">White</option>
            </select>
        </div>

        <script>
            class WebGLViewer {
                constructor() {
                    this.container = document.getElementById("webgl-container");
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(
                        75,
                        this.container.clientWidth /
                            this.container.clientHeight,
                        0.1,
                        1000,
                    );
                    this.renderer = new THREE.WebGLRenderer();
                    this.renderer.setSize(
                        this.container.clientWidth,
                        this.container.clientHeight,
                    );

                    this.shapeSelector =
                        document.getElementById("shape-selector");
                    this.shapeSelector.addEventListener("change", (e) =>
                        this.onShapeChange(e),
                    );

                    // Add file input for OBJ upload
                    this.fileInput = document.createElement("input");
                    this.fileInput.type = "file";
                    this.fileInput.accept = ".obj";
                    this.fileInput.style.display = "none";
                    this.fileInput.addEventListener("change", (e) =>
                        this.onFileUpload(e),
                    );
                    this.container.appendChild(this.fileInput);

                    // Add delete button
                    this.deleteButton = document.createElement("button");
                    this.deleteButton.textContent = "Delete Object";
                    this.deleteButton.style.display = "none";
                    this.deleteButton.addEventListener("click", () =>
                        this.deleteCurrentObject(),
                    );
                    this.container.appendChild(this.deleteButton);

                    this.isMouseDown = false;
                    this.mouseX = 0;
                    this.mouseY = 0;
                    this.targetRotationX = 0;
                    this.targetRotationY = 0;
                    this.isPanning = false;
                    this.panStart = new THREE.Vector2();
                    this.panEnd = new THREE.Vector2();
                    this.panDelta = new THREE.Vector2();

                    this.rotationGroup = new THREE.Group();
                    this.scene.add(this.rotationGroup);

                    this.renderer.domElement.addEventListener(
                        "pointerdown",
                        (e) => this.onPointerDown(e),
                    );
                    this.renderer.domElement.addEventListener(
                        "pointermove",
                        (e) => this.onPointerMove(e),
                    );
                    this.renderer.domElement.addEventListener("pointerup", () =>
                        this.onPointerUp(),
                    );
                    this.renderer.domElement.addEventListener(
                        "pointerleave",
                        () => this.onPointerUp(),
                    );

                    this.container.appendChild(this.renderer.domElement);

                    this.camera.position.z = 5;

                    this.setupLighting();
                    this.createGeometries();
                    this.loadStoredObjects();
                    this.onShapeChange();
                    this.updateShape();

                    window.addEventListener("resize", () =>
                        this.onWindowResize(),
                    );

                    this.animate();
                }

                setupLighting() {
                    const ambientLight = new THREE.AmbientLight(0x404040);
                    this.scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(
                        0xffffff,
                        0.5,
                    );
                    directionalLight.position.set(1, 1, 1);
                    this.scene.add(directionalLight);
                }

                createGeometries() {
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x00ff00,
                    });

                    this.geometries = {
                        sphere: new THREE.Mesh(
                            new THREE.SphereGeometry(1, 32, 32),
                            material,
                        ),
                        cube: new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            material,
                        ),
                        cylinder: new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 1, 32),
                            material,
                        ),
                        cone: new THREE.Mesh(
                            new THREE.ConeGeometry(0.5, 1, 32),
                            material,
                        ),
                        upload: null, // Placeholder for uploaded objects
                    };

                    // Adjust initial rotation for cylinder and cone
                    this.geometries.cylinder.rotation.x = Math.PI / 2;
                    this.geometries.cone.rotation.x = Math.PI / 2;
                }

                createGeometries() {
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x00ff00,
                    });

                    this.geometries = {
                        sphere: new THREE.Mesh(
                            new THREE.SphereGeometry(1, 32, 32),
                            material,
                        ),
                        cube: new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            material,
                        ),
                        cylinder: new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 1, 32),
                            material,
                        ),
                        cone: new THREE.Mesh(
                            new THREE.ConeGeometry(0.5, 1, 32),
                            material,
                        ),
                        upload: null, // Placeholder for uploaded objects
                    };

                    // Adjust initial rotation for cylinder and cone
                    this.geometries.cylinder.rotation.x = Math.PI / 2;
                    this.geometries.cone.rotation.x = Math.PI / 2;
                }

                loadStoredObjects() {
                    const storedObjects =
                        JSON.parse(localStorage.getItem("storedObjects")) || {};

                    for (const [name, objData] of Object.entries(
                        storedObjects,
                    )) {
                        this.addObjectToGeometries(name, objData);
                        this.addOptionToSelector(name);
                    }
                }

                addObjectToGeometries(name, objData) {
                    const loader = new THREE.OBJLoader();
                    const object = loader.parse(objData);
                    const material = new THREE.MeshPhongMaterial({
                        color: 0x00ff00,
                    });
                    object.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                        }
                    });
                    this.geometries[name] = object;
                }

                addOptionToSelector(name) {
                    const option = document.createElement("option");
                    option.value = name;
                    option.textContent = name;
                    this.shapeSelector.appendChild(option);
                }

                onShapeChange() {
                    this.currentShape = this.shapeSelector.value;
                    if (this.currentShape === "upload") {
                        this.fileInput.click();
                    } else {
                        this.updateShape();
                    }
                    this.updateDeleteButtonVisibility();
                }

                updateDeleteButtonVisibility() {
                    const isCustomObject = ![
                        "sphere",
                        "cube",
                        "cylinder",
                        "cone",
                        "upload",
                    ].includes(this.currentShape);
                    this.deleteButton.style.display = isCustomObject
                        ? "inline-block"
                        : "none";
                }

                onFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const objData = e.target.result;
                        this.promptForObjectName(objData);
                    };
                    reader.readAsText(file);
                }

                promptForObjectName(objData) {
                    const name = prompt(
                        "Enter a name for the uploaded object:",
                        "",
                    );
                    if (name) {
                        this.addObjectToGeometries(name, objData);
                        this.addOptionToSelector(name);

                        // Store in local storage
                        const storedObjects =
                            JSON.parse(localStorage.getItem("storedObjects")) ||
                            {};
                        storedObjects[name] = objData;
                        localStorage.setItem(
                            "storedObjects",
                            JSON.stringify(storedObjects),
                        );

                        this.shapeSelector.value = name;
                        this.currentShape = name;
                        this.updateShape();
                        this.updateDeleteButtonVisibility();
                    }
                }

                deleteCurrentObject() {
                    if (
                        confirm(
                            `Are you sure you want to delete "${this.currentShape}"?`,
                        )
                    ) {
                        // Remove from geometries
                        delete this.geometries[this.currentShape];

                        // Remove from selector
                        const option = this.shapeSelector.querySelector(
                            `option[value="${this.currentShape}"]`,
                        );
                        if (option) option.remove();

                        // Remove from local storage
                        const storedObjects =
                            JSON.parse(localStorage.getItem("storedObjects")) ||
                            {};
                        delete storedObjects[this.currentShape];
                        localStorage.setItem(
                            "storedObjects",
                            JSON.stringify(storedObjects),
                        );

                        // Reset to default shape
                        this.shapeSelector.value = "sphere";
                        this.onShapeChange();
                    }
                }

                updateShape() {
                    this.rotationGroup.clear();
                    if (this.geometries[this.currentShape]) {
                        this.rotationGroup.add(
                            this.geometries[this.currentShape],
                        );
                    }
                    this.animate();
                }
                onWindowResize() {
                    this.camera.aspect =
                        this.container.clientWidth /
                        this.container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(
                        this.container.clientWidth,
                        this.container.clientHeight,
                    );
                }

                onPointerDown(event) {
                    this.isMouseDown = true;
                    this.mouseX = event.clientX;
                    this.mouseY = event.clientY;
                    this.animate();
                }

                onPointerMove(event) {
                    if (!this.isMouseDown) return;

                    const deltaX = event.clientX - this.mouseX;
                    const deltaY = event.clientY - this.mouseY;

                    this.targetRotationY += deltaX * 0.01;
                    this.targetRotationX += deltaY * 0.01;

                    this.mouseX = event.clientX;
                    this.mouseY = event.clientY;
                }

                onPointerUp() {
                    this.isMouseDown = false;
                }

                pan(deltaX, deltaY) {
                    const speed = 0.01;
                    const distance = this.camera.position.z;
                    const panLeft = new THREE.Vector3();
                    const panUp = new THREE.Vector3();
                    const vec = new THREE.Vector3();

                    vec.setFromMatrixColumn(this.camera.matrix, 0);
                    panLeft.crossVectors(this.camera.up, vec);
                    panLeft.multiplyScalar(-deltaX * speed * distance);

                    vec.setFromMatrixColumn(this.camera.matrix, 1);
                    panUp.copy(vec);
                    panUp.multiplyScalar(deltaY * speed * distance);

                    this.camera.position.add(panLeft);
                    this.camera.position.add(panUp);
                    this.rotationGroup.position.add(panLeft);
                    this.rotationGroup.position.add(panUp);
                }

                animate() {
                    if (this.isMouseDown || this.isPanning) {
                        requestAnimationFrame(() => this.animate());
                    }

                    // Smoothly interpolate current rotation to target rotation
                    this.rotationGroup.rotation.y +=
                        (this.targetRotationY - this.rotationGroup.rotation.y) *
                        0.1;
                    this.rotationGroup.rotation.x +=
                        (this.targetRotationX - this.rotationGroup.rotation.x) *
                        0.1;

                    this.renderer.render(this.scene, this.camera);
                }
            }

            class DrawingTool {
                constructor() {
                    this.canvas = document.getElementById("drawing-canvas");
                    this.ctx = this.canvas.getContext("2d");
                    this.tempCanvas = document.getElementById("temp-canvas");
                    this.tempCtx = this.tempCanvas.getContext("2d");
                    this.brushCursor = document.getElementById("brush-cursor");
                    this.sizeSlider = document.getElementById("size-slider");
                    this.sizeValue = document.getElementById("size-value");

                    this.backgroundColorPicker =
                        document.getElementById("background-color");
                    this.penColorSelector =
                        document.getElementById("pen-color");
                    this.penColor = this.penColorSelector.value;

                    this.isDrawing = false;
                    this.points = [];
                    this.lastPoint = null;
                    this.maxBrushSize = 50;
                    this.undoStack = [];

                    this.initializeEventListeners();
                    this.resizeCanvas();
                    this.updateMaxBrushSize();
                    this.updateBackgroundColor();
                    this.saveState();
                }

                initializeEventListeners() {
                    window.addEventListener("resize", () =>
                        this.resizeCanvas(),
                    );
                    this.sizeSlider.addEventListener("input", () =>
                        this.updateMaxBrushSize(),
                    );
                    this.tempCanvas.addEventListener("pointerdown", (e) =>
                        this.startDrawing(e),
                    );
                    this.tempCanvas.addEventListener("pointermove", (e) =>
                        this.draw(e),
                    );
                    this.tempCanvas.addEventListener("pointerup", () =>
                        this.stopDrawing(),
                    );
                    this.tempCanvas.addEventListener("pointerleave", () =>
                        this.stopDrawing(),
                    );
                    this.tempCanvas.addEventListener("pointermove", (e) =>
                        this.updateBrushCursor(e),
                    );
                    this.tempCanvas.addEventListener("pointerleave", () =>
                        this.hideBrushCursor(),
                    );

                    this.backgroundColorPicker.addEventListener("input", () =>
                        this.updateBackgroundColor(),
                    );
                    this.penColorSelector.addEventListener("change", () =>
                        this.updatePenColor(),
                    );

                    document.addEventListener("keydown", (e) => {
                        if (e.ctrlKey && e.key === "z") {
                            e.preventDefault();
                            this.undo();
                        }
                    });
                }

                resizeCanvas() {
                    const container =
                        document.getElementById("drawing-container");
                    const tempImageData = this.ctx.getImageData(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height,
                    );
                    this.canvas.width = this.tempCanvas.width =
                        container.clientWidth;
                    this.canvas.height = this.tempCanvas.height =
                        container.clientHeight;
                    this.ctx.putImageData(tempImageData, 0, 0);
                    [this.ctx, this.tempCtx].forEach((ctx) => {
                        ctx.lineCap = ctx.lineJoin = "round";
                    });
                }

                updateMaxBrushSize() {
                    this.maxBrushSize = parseInt(this.sizeSlider.value);
                    this.sizeValue.textContent = `Max: ${this.maxBrushSize}px`;
                }

                updateBackgroundColor() {
                    const color = this.backgroundColorPicker.value;
                    this.canvas.style.backgroundColor = color;
                }

                updatePenColor() {
                    this.penColor = this.penColorSelector.value;
                }

                updateBrushCursor(e) {
                    const pressure =
                        e.pressure !== undefined ? e.pressure : 0.5;
                    const size = this.calculateCursorSize(pressure);
                    this.brushCursor.style.left = `${e.clientX - size}px`;
                    this.brushCursor.style.top = `${e.clientY - size}px`;
                    this.brushCursor.style.display = "block";
                    this.brushCursor.setAttribute("width", size * 2);
                    this.brushCursor.setAttribute("height", size * 2);
                    this.brushCursor.firstElementChild.setAttribute("cx", size);
                    this.brushCursor.firstElementChild.setAttribute("cy", size);
                    this.brushCursor.firstElementChild.setAttribute(
                        "r",
                        size - 1,
                    );
                    const opacity = 1;
                    this.brushCursor.firstElementChild.setAttribute(
                        "stroke-opacity",
                        opacity,
                    );
                }

                calculateCursorSize(pressure) {
                    return Math.max(4, this.maxBrushSize * pressure);
                }

                calculateBrushSize(pressure) {
                    return Math.max(1, this.maxBrushSize * pressure);
                }

                calculateOpacity(pressure) {
                    return Math.max(0.1, pressure);
                }

                hideBrushCursor() {
                    this.brushCursor.style.display = "none";
                }

                startDrawing(e) {
                    this.isDrawing = true;
                    this.points = [];
                    this.lastPoint = null;
                    this.addPoint(e);
                }

                draw(e) {
                    if (!this.isDrawing) return;
                    e.preventDefault();
                    this.addPoint(e);
                    this.drawCachedLine();
                }

                addPoint(e) {
                    const pressure = e.pressure || 0;
                    if (pressure === 0 || pressure === 0.5) return;

                    const newPoint = {
                        x: e.offsetX,
                        y: e.offsetY,
                        pressure: pressure,
                    };

                    this.points.push(newPoint);
                    this.lastPoint = newPoint;
                }

                drawCachedLine() {
                    this.tempCtx.clearRect(
                        0,
                        0,
                        this.tempCanvas.width,
                        this.tempCanvas.height,
                    );

                    if (this.points.length < 2) return;

                    this.tempCtx.beginPath();

                    const catmullRom = (p0, p1, p2, p3, t) => {
                        const t2 = t * t;
                        const t3 = t2 * t;
                        return {
                            x:
                                0.5 *
                                (2 * p1.x +
                                    (-p0.x + p2.x) * t +
                                    (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) *
                                        t2 +
                                    (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                            y:
                                0.5 *
                                (2 * p1.y +
                                    (-p0.y + p2.y) * t +
                                    (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) *
                                        t2 +
                                    (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3),
                            pressure:
                                0.5 *
                                (2 * p1.pressure +
                                    (-p0.pressure + p2.pressure) * t +
                                    (2 * p0.pressure -
                                        5 * p1.pressure +
                                        4 * p2.pressure -
                                        p3.pressure) *
                                        t2 +
                                    (-p0.pressure +
                                        3 * p1.pressure -
                                        3 * p2.pressure +
                                        p3.pressure) *
                                        t3),
                        };
                    };
                    if (this.points.length >= 4) {
                        for (let i = 0; i < this.points.length - 3; i++) {
                            const p0 = this.points[i];
                            const p1 = this.points[i + 1];
                            const p2 = this.points[i + 2];
                            const p3 = this.points[i + 3];

                            for (let t = 0; t <= 1; t += 0.1) {
                                const pt = catmullRom(p0, p1, p2, p3, t);
                                const size = this.calculateBrushSize(
                                    pt.pressure,
                                );
                                const opacity = this.calculateOpacity(
                                    pt.pressure,
                                );

                                this.tempCtx.lineWidth = size;
                                let color =
                                    this.penColor === "white"
                                        ? `rgba(255, 255, 255, ${this.calculateOpacity(opacity)})`
                                        : `rgba(0, 0, 0, ${this.calculateOpacity(opacity)})`;

                                this.tempCtx.strokeStyle = color;
                                this.tempCtx.lineTo(pt.x, pt.y);
                                this.tempCtx.stroke();
                                this.tempCtx.beginPath();
                                this.tempCtx.moveTo(pt.x, pt.y);
                            }
                        }
                    } else {
                        this.points.forEach((point) => {
                            this.tempCtx.lineWidth = this.calculateBrushSize(
                                point.pressure,
                            );
                            let color =
                                this.penColor === "white"
                                    ? `rgba(255, 255, 255, ${this.calculateOpacity(point.pressure)})`
                                    : `rgba(0, 0, 0, ${this.calculateOpacity(point.pressure)})`;

                            this.tempCtx.strokeStyle = color;
                            this.tempCtx.lineTo(point.x, point.y);
                            this.tempCtx.stroke();
                            this.tempCtx.beginPath();
                            this.tempCtx.moveTo(point.x, point.y);
                        });
                    }
                }

                stopDrawing() {
                    if (this.isDrawing) {
                        this.isDrawing = false;
                        this.ctx.drawImage(this.tempCanvas, 0, 0);
                        this.tempCtx.clearRect(
                            0,
                            0,
                            this.tempCanvas.width,
                            this.tempCanvas.height,
                        );
                        this.saveState();
                    }
                }

                saveState() {
                    this.undoStack.push(this.canvas.toDataURL());
                }

                undo() {
                    if (this.undoStack.length > 1) {
                        this.undoStack.pop();
                        const img = new Image();
                        img.onload = () => {
                            this.ctx.clearRect(
                                0,
                                0,
                                this.canvas.width,
                                this.canvas.height,
                            );
                            this.ctx.drawImage(img, 0, 0);
                        };
                        img.src = this.undoStack[this.undoStack.length - 1];
                    } else if (this.undoStack.length === 1) {
                        this.ctx.clearRect(
                            0,
                            0,
                            this.canvas.width,
                            this.canvas.height,
                        );
                    }
                }
            }

            new WebGLViewer();
            new DrawingTool();
        </script>
    </body>
</html>
