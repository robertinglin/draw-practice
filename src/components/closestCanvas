import React, { useRef, useState, useEffect, useCallback } from 'react';
import { getStroke } from 'perfect-freehand';

const MIN_DISTANCE = 1; // Minimum distance between points in pixels

const DrawingCanvas = () => {
    const canvasRef = useRef(null);
    const [isDrawing, setIsDrawing] = useState(false);
    const [isErasing, setIsErasing] = useState(false);
    const [currentStroke, setCurrentStroke] = useState([]);
    const [allStrokes, setAllStrokes] = useState([]);

    const getStrokePoints = useCallback((stroke) => {
        return getStroke(stroke, {
            size: 64,
            thinning: 0.5,
            smoothing: 0.5,
            streamline: 0.5,
        });
    }, []);

    const drawStroke = useCallback((ctx, strokePoints, color, skipSegments = []) => {
        const isBlue = color.toLowerCase() === 'blue';
        ctx.beginPath();
        let isDrawing = true;
        for (let i = 0; i < strokePoints.length; i++) {
            const segment1 = skipSegments.find(segment => segment[0] === i);
            const segment2 = skipSegments.find(segment => segment[1] === i);
            if (segment1) {
                ctx.lineTo(segment1[2][0], segment1[2][1]);
                ctx.stroke(); // End the current path
                isDrawing = false;
            }
            if (skipSegments.some(segment => segment[1] === i)) {
                ctx.beginPath(); // Start a new path
                ctx.moveTo(segment2[3][0], segment2[3][1]);
                isDrawing = true;
            }
            if (i === 0 || !isDrawing) {
                ctx.moveTo(strokePoints[i][0], strokePoints[i][1]);
            } else {
                if (isBlue && i > 0) {
                    const prevY = strokePoints[i-1][1];
                    const currentY = strokePoints[i][1];
                    ctx.strokeStyle = currentY > prevY ? 'blue' : 'orange';
                } else {
                    ctx.strokeStyle = color;
                }
                ctx.beginPath();
                ctx.moveTo(strokePoints[i-1][0], strokePoints[i-1][1]);
                ctx.lineTo(strokePoints[i][0], strokePoints[i][1]);
                ctx.stroke();
            }
        }
    }, []);
    // Helper function to calculate line intersection
    const lineIntersection = (p1, p2, p3, p4) => {
        const x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1];
        const x3 = p3[0], y3 = p3[1], x4 = p4[0], y4 = p4[1];

        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (denom === 0) return null; // parallel lines

        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null; // out of segment bounds

        const x = x1 + ua * (x2 - x1);
        const y = y1 + ua * (y2 - y1);

        return [x, y];
    };

        const redrawCanvas = useCallback(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        allStrokes.forEach((stroke, index) => {
            const strokePoints = getStrokePoints(stroke.points);
            const intersections = [];

            if (!stroke.isEraser) {
                // Check for intersections with eraser strokes that come after this stroke
                for (let i = index + 1; i < allStrokes.length; i++) {
                    if (allStrokes[i].isEraser) {
                        const eraserPoints = getStrokePoints(allStrokes[i].points);

                        for (let j = 1; j < strokePoints.length; j++) {
                            const p1 = strokePoints[j - 1];
                            const p2 = strokePoints[j];

                            for (let k = 1; k < eraserPoints.length; k++) {
                                const p3 = eraserPoints[k - 1];
                                const p4 = eraserPoints[k];

                                const intersection = lineIntersection(p1, p2, p3, p4);
                                if (intersection) {
                                    intersections.push({ point: intersection, index: j - 1 });
                                }
                            }
                        }
                    }
                }

                // Sort intersections by their index
                intersections.sort((a, b) => a.index - b.index);

                // Create segments to draw
                const segments = [];
                let start = 0;
                let isDrawing = true;

                for (let i = 0; i < intersections.length; i++) {
                    const intersection = intersections[i];
                    if (isDrawing) {
                        segments.push({
                            start: start,
                            end: intersection.index,
                            startPoint: i === 0 ? strokePoints[start] : intersections[i - 1].point,
                            endPoint: intersection.point
                        });
                    }
                    start = intersection.index;
                    isDrawing = !isDrawing;
                }

                if (isDrawing) {
                    segments.push({
                        start: start,
                        end: strokePoints.length - 1,
                        startPoint: intersections.length > 0 ? intersections[intersections.length - 1].point : strokePoints[start],
                        endPoint: strokePoints[strokePoints.length - 1]
                    });
                }

                // Draw the segments
                segments.forEach(segment => {
                    ctx.beginPath();
                    ctx.moveTo(segment.startPoint[0], segment.startPoint[1]);
                    for (let i = segment.start + 1; i <= segment.end; i++) {
                        const point = strokePoints[i];
                        ctx.lineTo(point[0], point[1]);
                    }
                    ctx.lineTo(segment.endPoint[0], segment.endPoint[1]);
                    ctx.strokeStyle = stroke.isEraser ? 'red' : 'blue';
                    ctx.stroke();
                });

                // Draw intersection points
                ctx.fillStyle = 'purple';
                intersections.forEach(({ point }) => {
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            } else {
                // Draw eraser strokes
                drawStroke(ctx, strokePoints, 'red');
            }

            if (!stroke.isEraser) return;
            // Draw current points
            ctx.fillStyle = 'blue';
            strokePoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            });
        });

        // Draw current stroke
        if (currentStroke.length > 0) {
            const strokePoints = getStrokePoints(currentStroke);
            drawStroke(ctx, strokePoints, isErasing ? 'red' : 'blue');
        }
    }, [allStrokes, currentStroke, isErasing, getStrokePoints, drawStroke]);
    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
    }, []);

    useEffect(() => {
        redrawCanvas();
    }, [allStrokes, currentStroke, redrawCanvas]);

    const getCanvasPoint = useCallback((e) => {
        const canvas = canvasRef.current;
        if (!canvas) return [0, 0];

        const rect = canvas.getBoundingClientRect();
        return [
            e.clientX - rect.left,
            e.clientY - rect.top
        ];
    }, []);

    const handlePointerDown = useCallback((e) => {
        setIsDrawing(true);
        const [x, y] = getCanvasPoint(e);
        setCurrentStroke([[x, y, 0]]);  // Initial angle is 0
    }, [getCanvasPoint]);

    const handlePointerMove = useCallback((e) => {
        if (!isDrawing) return;
        const [x, y] = getCanvasPoint(e);

        setCurrentStroke(prev => {
            const lastPoint = prev[prev.length - 1];
            const dx = x - lastPoint[0];
            const dy = y - lastPoint[1];
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance >= MIN_DISTANCE) {
                const angle = Math.atan2(dy, dx);
                return [...prev, [x, y, angle]];
            }
            return prev;
        });

    }, [isDrawing, getCanvasPoint]);

    const handlePointerUp = useCallback(() => {
        if (currentStroke.length > 0) {
            setAllStrokes(prev => [...prev, { points: currentStroke, isEraser: isErasing }]);
        }
        setIsDrawing(false);
        setCurrentStroke([]);
    }, [currentStroke, isErasing]);

    return (
        <div>
            <label>
                <input
                    type="checkbox"
                    checked={isErasing}
                    onChange={(e) => setIsErasing(e.target.checked)}
                />
                Eraser Mode
            </label>
            <canvas
                ref={canvasRef}
                width={1000}
                height={1000}
                style={{ border: '1px solid black', touchAction: 'none' }}
                onPointerDown={handlePointerDown}
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
            />
        </div>
    );
};

export default DrawingCanvas;